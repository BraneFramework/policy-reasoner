// WORKFLOW EXT.eflint
//   by Lut99
//
// Created:
//   30 Nov 2023, 11:33:50
// Last edited:
//   06 Dec 2023, 12:31:13
// Auto updated?
//   Yes
//
// Description:
//   Defines Facts that can be derived from every workflow. Not part of the
//   standard interface, but more like standard library.
//

#require "workflow_base.eflint".


// Automatically derives that a node exists if a task or commit exists.
Extend Fact node
    Derived from (Foreach task : task.node)
    Derived from (Foreach commit : commit.node).

// Unifies inputs and outputs of a node.
Fact node-asset Identified by node * asset
    Holds when (node-input(node, asset) || node-output(node, asset)).
// Unifies asset inputs and code to a task.
Fact task-input-asset Identified by task * asset
    Holds when (node-input(task.node, asset) || task-code(task(node), code(asset))).
// Unifies asset inputs, outputs and code to a task.
Fact task-asset Identified by task * asset
    Holds when (task-input-asset(task, asset) || node-output(task.node, asset)).

// Compute the assets on all domains that compute stuff
Extend Fact asset-access
    Holds when (Exists task : task-asset(task, asset) && task-at(task, domain)).

// Indicates that the input of the first node \*might\* depend on the output of the second. Whether this is actually the case depends on dynamic control flow.
Fact node-depends-on Identified by node1 * node2
    Holds when node1 == node2
    Holds when (Exists asset : node-input(node1, asset) && node-output(node2, asset))
    Holds when (Exists node' : node-depends-on(node1, node') && node-depends-on(node', node2)).
// Derives a concrete relation of all the assets upon which a node depends.
Fact node-depends-on-asset Identified by node * asset
    Derived from (Foreach node-depends-on, asset : node-depends-on-asset(node-depends-on.node1, asset) When node-input(node-depends-on.node2, asset)).

// Derives all the domains to which an asset downstreams.
Fact asset-downstream-domain Identified by asset * domain
    Derived from (Foreach node-depends-on-asset, domain : asset-downstream-domain(node-depends-on-asset.asset, domain) When task(node-depends-on-asset.node) && task-at(task(node-depends-on-asset.node), domain)).

// // A predicate over `node-input` that denotes it isn't a _possible_ input dataset, but an _ensured_ input dataset. Note that, for `commit`s, this can be at most 1, (correctly) implying `commit` can only commit a single dataset at a time.
// Fact node-input-ensured Identified by node-input
//     Derived from (Foreach node, asset : node-input-ensured(node-input(node, asset)) When node-input(node, asset)).

// // Relates an asset to all of its "children"
// Fact asset-downstream Identified by asset1 * asset2
//     Holds when (asset1 == asset2)
//     Holds when (Exists node : node-input(node, asset1) && node-output(node, asset2))
//     // Editor's note: super slow, might comment-out if too slow
//     Holds when (Exists asset' : asset-downstream(asset1, asset') && asset-downstream(asset', asset2)).
// Fact asset-touches Identified by asset * domain
//     Holds when asset-access(asset, domain.user)
//     Holds when (Exists commit, asset' : node-output(commit.node, asset')).

// // Relates an asset to all locations that it touches based on the given workflow.
// Fact asset-touches Identified by asset * domain
//     Holds when (asset-access(asset, domain.user))
//     Holds when (Exists task : (node-input(task.node, asset) || node-output(task.node, asset)) && task-at(task, domain)).
// Fact asset-touches-tree Identified by asset * domain
//     Holds when (asset-touches(asset, domain))
//     Derived from (Foreach asset, domain, asset', domain' : asset-touched(asset, domain') When (Exists node1, node2 : node-output(node1, asset) && node-input(node2, asset') && node-at(node2, domain'))).
